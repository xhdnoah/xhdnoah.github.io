<!doctype html><html><head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<link rel=stylesheet type=text/css href=/css/bootstrap.min.css>
<link rel=stylesheet type=text/css href=/css/style.css>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/themes/prism.css>
<link rel=icon type=image/png href=/images/favicon.ico>
<link rel=icon href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%221em%22 font-size=%2280%22>ğŸŒ•</text></svg>">
<script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/components/prism-core.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/autoloader/prism-autoloader.min.js></script>
<script defer src=https://use.fontawesome.com/93f8d6d0b2.js></script>
<title>ç”µå­æœˆäº® | Vue åˆå§‹åŒ–ï¼šä» new Vue(...) åˆ° DOM Tree</title>
</head>
<body>
<header class="header fadeInTop content">
<a class=no-highlight href=/>ElectronicMoon</a>
</header>
<main class=main>
<div class="content-container fadeInTop">
<div class=content>
<h1 class=title>Vue åˆå§‹åŒ–ï¼šä» new Vue(...) åˆ° DOM Tree</h1>
<div class=post-meta>
<time datetime="2019-12-18 00:00:00 +0000 UTC">Dec 18, 2019</time>
</div>
<p>è¿™ç¯‡æ–‡ç« å°†ä»æˆ‘è‡ªå·±çš„ç†è§£æè¿°ä¸€ä¸ª Vue.js é¡¹ç›®æ˜¯æ€ä¹ˆä»é›¶å¼€å§‹åˆå§‹åŒ–çš„ä¸»çº¿è¿‡ç¨‹ï¼Œä»¥å…³é”®å‡½æ•°çš„è°ƒç”¨æ ˆä¸ºçº¿ç´¢ï¼Œä¼šç•¥è¿‡å¾ˆå¤šç¹ççš„æ®µè½ï¼Œåˆ†æ Vue.js åœ¨åˆå§‹åŒ–è¿‡ç¨‹ä¸­çš„å…³é”®èŠ‚ç‚¹ï¼Œæˆ‘è§‰å¾—é˜…è¯»æºç ä¸èƒ½åƒçœ‹å°è¯´é‚£æ ·ï¼Œçº¿æ€§åœ°è¿½å¯»æ— é™çš„ç»†èŠ‚ï¼Œè€Œæ˜¯åœ¨è„‘æµ·ä¸­å»ºç«‹å…³é”®èŠ‚ç‚¹çš„ç´¢å¼•å’Œæ ¸å¿ƒåŸç†çš„ç†è§£ï¼Œè¿™æ ·åœ¨éœ€è¦å›å¤´å…·ä½“åˆ†ææŸä¸€å¤„æˆ–è€…å¯¹å“ªéƒ¨åˆ†æ„Ÿå…´è¶£çš„æ—¶å€™å°±å¯ä»¥å¿«é€Ÿå®šä½åˆ°</p>
<h3 id=æ„é€ å‡½æ•°åˆå§‹åŒ–>æ„é€ å‡½æ•°åˆå§‹åŒ–</h3>
<p>ä¸€ä¸ª Vue.js åº”ç”¨ç”±ä¸€ä¸ªæ ¹å®ä¾‹å’Œå¯åµŒå¥—çš„ç»„ä»¶æ ‘æ„æˆï¼Œè€Œç»„ä»¶éƒ½æ˜¯å¯å¤ç”¨çš„ Vue å®ä¾‹ï¼Œå¯ä»¥ä»å…¥å£æ–‡ä»¶ <code>entry-runtime-with-compiler.js -> runtime/index.js -> core/index.js -> instance/index.js</code> è¿™æ¡çº¿æ‰¾åˆ° Vue æ„é€ å‡½æ•°</p>
<pre><code class=language-javascript>import { initMixin } from './init'
import { stateMixin } from './state'
import { renderMixin } from './render'
import { eventsMixin } from './events'
import { lifecycleMixin } from './lifecycle'
import { warn } from '../util/index'

function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &amp;&amp;
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}

initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)
</code></pre>
<p>Vue æŠŠåˆå§‹åŒ–ã€æ•°æ®çŠ¶æ€ã€äº‹ä»¶ã€ç”Ÿå‘½å‘¨æœŸã€æ¸²æŸ“ç›¸å…³çš„é€»è¾‘æ‹†åˆ†ä¸ºå•ç‹¬çš„æ¨¡å—ï¼Œåˆ†åˆ«æŒ‚è½½åˆ° Vue.prototype åŸå‹ä¸Šï¼Œæ„é€ å‡½æ•°æœ¬èº«åªæ‰§è¡Œ init æ–¹æ³•</p>
<p>é™¤äº†å®ä¾‹æ–¹æ³•ï¼Œåœ¨ core/index.js ä¸­çš„<code>initGlobalAPI</code> è¿˜ç»™ Vue æœ¬èº«æ·»åŠ å…¨å±€çš„ APIï¼Œå¦‚ <code>Vue.set, Vue.nextTick, Vue.util</code> ç­‰ï¼Œå…¶ä¸­ <code>Vue.options._base = Vue</code> æ˜¯ä¿æŒå¯¹ Vue æ„é€ å‡½æ•°çš„å¼•ç”¨ï¼Œä¼šç”¨ä½œå­ç»„ä»¶çš„åˆ›å»ºã€‚</p>
<h3 id=vue-å®ä¾‹åˆå§‹åŒ–>Vue å®ä¾‹åˆå§‹åŒ–</h3>
<pre><code class=language-javascript>Vue.property._init = function(options?: Object){
  const vm: Component = this
  vm._uid = uid++
  vm._isVue = true
	// merge options
  if(options &amp;&amp; options._isComponent){
    initInternalComponent(vm, options)
  } else {
    vm.$options = mergeOptions(
      resolveConstructorOptions(vm.constructor),
      options || {},
      vm
    )
  }
	// expose real self
	vm._self = vm
	initLifecycle(vm)
	initEvents(vm)
	initRender(vm)
	callHook(vm, 'beforeCreate')
	initInjections(vm)
	initState(vm)
	initProvide(vm)
	callHook(vm, 'created')
	...
	if(vm.$options.el){
		vm.$mount(vm.$options.el)
	}
}
</code></pre>
<p><strong>mergeOptions</strong></p>
<p><code>resolveConstructorOptions</code> é€’å½’è·å–æ‰€æœ‰ç»„ä»¶çš„é»˜è®¤å‚æ•°ï¼Œ<code>mergeOptions</code> è§„èŒƒåŒ–ç”¨æˆ·å‚æ•°ç„¶ååˆå¹¶ç”¨æˆ·å‚æ•°å’Œé»˜è®¤å‚æ•°ï¼Œç”¨æˆ·å‚æ•°å°±æ˜¯ä½ å†™çš„ name,data,props,method å’Œç”Ÿå‘½å‘¨æœŸé’©å­ç­‰ï¼Œåˆå¹¶åçš„æ‰€æœ‰å‚æ•°æŒ‡å‘ <code>vm.$options</code></p>
<p><strong>beforeCreate</strong></p>
<p>æ­¤æ—¶è¿˜ä¸èƒ½è®¿é—®æ•°æ®ï¼Œå¯ä»¥å®Œæˆå’Œåç«¯äº¤äº’çš„åˆå§‹åŒ–æ“ä½œ</p>
<p><strong>initData</strong></p>
<blockquote>
<p>initState åŒ…å«åˆå§‹åŒ– data props methods computed watchï¼Œè¿™é‡Œä»¥ initData ä¸¾ä¾‹</p>
</blockquote>
<pre><code class=language-javascript>function initData(vm: Component){
  let data = vm.$options.data
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
  	: data || {}
  // proxy data on instance
  // check if keys are repeated
  const keys = Object.keys(data)
  const props = vm.$options.props
  const methods = vm.$options.methods
  let i = keys.length
  while (i--) {
    const key = keys[i]
    if (process.env.NODE_ENV !== 'production') {
      if (methods &amp;&amp; hasOwn(methods, key)) {
        warn(
          `Method &quot;${key}&quot; has already been defined as a data property.`,
          vm
        )
      }
    }
    if (props &amp;&amp; hasOwn(props, key)) {
      process.env.NODE_ENV !== 'production' &amp;&amp; warn(
        `The data property &quot;${key}&quot; is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
      )
    } else if (!isReserved(key)) {
      proxy(vm, `_data`, key)
    }
  }
  observe(data, true)
}
</code></pre>
<p>è¿™é‡Œä» vm.$options ä¸­å–å‡ºæ•°æ®åï¼ŒæŒ‡å‘ <code>vm._data</code>ï¼Œæ ¡éªŒ data çš„é”®å€¼æ˜¯å¦å’Œ method props é‡å¤ï¼Œé€šè¿‡ proxy å‡½æ•°ä»£ç† <code>vm._data</code> ä¸‹çš„ç§æœ‰æ•°æ®ï¼Œè¿™æ ·å½“æˆ‘ä»¬è®¿é—® <code>this.msg</code> å°±ç›¸å½“äºè®¿é—® <code>this._data.msg</code>ï¼Œæœ€ååœ¨ data å¯¹è±¡ä¸­æ·»åŠ  Observer, ç»‘å®šæ•°æ®åŠ«æŒ</p>
<p><strong>proxy</strong></p>
<pre><code class=language-javascript>const sharedPropertyDefinition = {
	enumerable: true,
	configurable: true,
	get: noop,
	set: noop
}

export function proxy(target: Object, sourceKey: string, key: string){
	sharedPropertyDefinition.get = function proxyGetter(){
		return this[sourceKey][key]
	}
  sharedPropertyDefinition.set = function proxySetter(val){
    this[sourceKey][key] = val
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}
</code></pre>
<p>proxy çš„å®ç°é€šè¿‡ Object.defineProperty å¯¹æ¯ä¸€ä¸ª data é¡¹è®¾ç½® getter å’Œ setter</p>
<h3 id=vm-å®ä¾‹æŒ‚è½½>vm å®ä¾‹æŒ‚è½½</h3>
<p><strong>vm.$mount</strong></p>
<pre><code class=language-javascript>Vue.property.$mount = function(
	el?: string | Element,
	hydrating?: boolean
): Component {
	el = el &amp;&amp; inBrowser ? query(el) : undefined
	return mountComponent(this, el, hydrating)
}
</code></pre>
<pre><code class=language-javascript>export function mountComponent(
	vm: Component,
	el: ?Element,
	hydrating?: boolean
): Component {
	vm.$el = el
	...
	callHook(vm, 'beforeMount')
	let updateComponent
	updateComponent = () =&gt; {
    // æ‰§è¡Œ _render ç”Ÿæˆ VNode
    vm_update(vm._render(), hydrating)
	}
  ...
  // renderWatcher
  new Watcher(vm, updateComponent, noop, {
    before(){
      if(vm._isMounted){
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true)

  return vm
}
</code></pre>
<p>compiler ç‰ˆæœ¬çš„å®ä¾‹æŒ‚è½½æœ€ç»ˆä¼šå®ä¾‹åŒ–ä¸€ä¸ªæ¸²æŸ“ Watcherï¼Œåœ¨å…¶åˆå§‹åŒ–ä»¥åŠæ£€æµ‹åˆ°æ•°æ®å˜åŒ–çš„æ—¶å€™æ‰§è¡Œå›è°ƒå‡½æ•° <code>updateComponent</code>ï¼Œ<code>updateComponent</code> è°ƒç”¨ <code>vm._render()</code> ç”Ÿæˆ Virtual DOMï¼Œæœ€ç»ˆè°ƒç”¨ <code>vm._update</code> æ›´æ–°åˆ°çœŸå® DOM</p>
<p><strong>vm._render</strong></p>
<pre><code class=language-javascript>Vue.prototype._render = function (): VNode {
	const vm: Component = this
	const { render, _parentVnode } = vm.$options
	if(_parentVnode){
		vm.$scopedSlots = normalizeScopedSlots(
			_parentVnode.data.scopedSlots,
			vm.$slots,
			vm.$scopedSlots
		)
	}

  vm.$vnode = _parentVnode
  let vnode
  try {
    currentRenderingInstance = vm
    // æ‰§è¡Œ createElement
    vnode = render.call(vm._renderProxy, vm.$createElement)
  } catch(e) {
    handleError(e, vm, `render`)
    // return error render result
    ...
  } finally {
    currentRenderingInstance = null
  }
  ...
  vnode.parent = _parentVnode
  return vnode
}
</code></pre>
<p><code>vm._render</code> æ ¸å¿ƒæ˜¯è°ƒç”¨<strong>ç”¨æˆ·æ‰‹å†™æˆ–ç¼–è¯‘ç”Ÿæˆçš„ render å‡½æ•°</strong>ï¼Œå¹¶å°† createElement å‡½æ•°ä½œä¸ºå‚æ•°ä¼ å…¥ï¼Œå½“æˆ‘ä»¬ä½¿ç”¨æ¨¡æ¿è¯­æ³•æ—¶</p>
<pre><code class=language-vue>// æ¨¡æ¿ç¼–è¯‘
&lt;div id=&quot;app&quot;&gt;
 {{ message }}
&lt;/div&gt;
</code></pre>
<p>template æœ€ç»ˆéƒ½ä¼šç¼–è¯‘æˆ render å‡½æ•°ï¼Œç›¸å½“äº</p>
<pre><code class=language-javascript>// æ‰‹å†™ render å‡½æ•°, createElement ä½œä¸ºå‚æ•°ä¼ å…¥åˆ›å»º VNode
var app = new Vue({
	el: '#app',
	render(createElement){
		return createElement('div', {
			attrs: {
				id: '#app'
			}
		}, this.message)
	}
})
</code></pre>
<p><strong>renderProxy</strong></p>
<p>render è°ƒç”¨ç»‘å®šäº† <code>vm._renderProxy</code> ä¸­çš„ this æŒ‡å‘ï¼Œ<code>vm._renderProxy</code> åœ¨ç”Ÿäº§ç¯å¢ƒæŒ‡å‘ vmï¼Œåœ¨å¼€å‘ç¯å¢ƒå¯¹ vm çš„è¯»å†™æ“ä½œè¿›è¡ŒåŠ«æŒå¹¶æ£€æµ‹é”™è¯¯</p>
<pre><code class=language-javascript>const hasHandler = {
  ...
  warnNonPresent(target, key)
}

const getHandler = {
  ...
  warnNonPresent(target, key)
}

initProxy = function initProxy (vm) {
	if(hasProxy){
		const options = vm.$options
    const handlers = options.render &amp;&amp; options.render._withStripped
    	? getHandler
    	: hasHandler
    vm._renderProxy = new Proxy(vm, handlers)
	} else {
    vm._renderProxy = vm
  }
}
</code></pre>
<p><code>warnNonPresent()</code> è¡¨ç¤ºå±æ€§æˆ–æ–¹æ³•æœªåœ¨å®ä¾‹ä¸Šå®šä¹‰</p>
<p><strong>Virtual DOM</strong></p>
<p>Virtual DOM æ˜¯ä¸€ä¸ªç”¨ JS å¯¹è±¡æè¿°çš„è™šæ‹Ÿ DOMèŠ‚ç‚¹ï¼ŒVue.js ç”¨ VNode ç±»æ¥æè¿° Virtual DOM</p>
<pre><code class=language-javascript>export default class VNode {
  tag: string | void;
  data: VNodeData | void;
  children: ?Array&lt;VNode&gt;;
  text: string | void;
  elm: Node | void;
  ns: string | void;
  context: Component | void; // rendered in this component's scope
  key: string | number | void;
  componentOptions: VNodeComponentOptions | void;
  componentInstance: Component | void; // component instance
  parent: VNode | void; // component placeholder node

  // strictly internal
  raw: boolean; // contains raw HTML? (server only)
  isStatic: boolean; // hoisted static node
  isRootInsert: boolean; // necessary for enter transition check
  isComment: boolean; // empty comment placeholder?
  isCloned: boolean; // is a cloned node?
  isOnce: boolean; // is a v-once node?
  asyncFactory: Function | void; // async component factory function
  asyncMeta: Object | void;
  isAsyncPlaceholder: boolean;
  ssrContext: Object | void;
  fnContext: Component | void; // real context vm for functional nodes
  fnOptions: ?ComponentOptions; // for SSR caching
  fnScopeId: ?string; // functional scope id support

  constructor (
    tag?: string,
    data?: VNodeData,
    children?: ?Array&lt;VNode&gt;,
    text?: string,
    elm?: Node,
    context?: Component,
    componentOptions?: VNodeComponentOptions,
    asyncFactory?: Function
  ) {
    this.tag = tag
    this.data = data
    this.children = children
    this.text = text
    this.elm = elm
    this.ns = undefined
    this.context = context
    this.fnContext = undefined
    this.fnOptions = undefined
    this.fnScopeId = undefined
    this.key = data &amp;&amp; data.key
    this.componentOptions = componentOptions
    this.componentInstance = undefined
    this.parent = undefined
    this.raw = false
    this.isStatic = false
    this.isRootInsert = true
    this.isComment = false
    this.isCloned = false
    this.isOnce = false
    this.asyncFactory = asyncFactory
    this.asyncMeta = undefined
    this.isAsyncPlaceholder = false
  }

  // DEPRECATED: alias for componentInstance for backwards compat.
  /* istanbul ignore next */
  get child (): Component | void {
    return this.componentInstance
  }
}
</code></pre>
<p>Vue.js ä¸­çš„ VNode è¿˜åˆ†ä¸º<strong>å ä½ç¬¦ VNode</strong> å’Œ <strong>æ¸²æŸ“ VNode</strong>ï¼Œå ä½ç¬¦ VNode å°±æ˜¯ç»„ä»¶åœ¨æ¸²æŸ“è¿‡ç¨‹ä¸­ç”¨æ¥å ä½çš„çˆ¶ VNodeï¼Œå¯ä»¥ç†è§£ä¸ºç»„ä»¶çš„æ ¹èŠ‚ç‚¹ï¼Œæ¸²æŸ“ VNode å°±æ˜¯æœ‰çœŸå® DOM æ˜ å°„å…³ç³»çš„ DOM èŠ‚ç‚¹ã€‚åœ¨å®ä¾‹å±æ€§ä¸­ï¼Œ <code>vm.$vnode</code> æŒ‡å‘å ä½ç¬¦èŠ‚ç‚¹ï¼Œ<code>vm._vnode</code> æŒ‡å‘æ¸²æŸ“èŠ‚ç‚¹</p>
<h4 id=åˆ›å»º-vnode>åˆ›å»º VNode</h4>
<p>Vue.js åˆ©ç”¨ createElement æ–¹æ³•åˆ›å»º VNodeï¼ŒcreateElement å°è£…äº† _createElement æ–¹æ³•ï¼Œåè€…ä¸»è¦å®Œæˆä¸¤ä»¶äº‹ï¼šå­èŠ‚ç‚¹çš„è§„èŒƒåŒ–å’Œ VNode çš„å®ä¾‹åŒ–ï¼Œä»¥ vuejs.org å®˜ç½‘çš„ demo ä¸ºä¾‹</p>
<pre><code class=language-javascript>// @returns {VNode}
createElement(
  // {String | Object | Function}
  // An HTML tag name, component options, or async
  // function resolving to one of these. Required.
  'div',

  // {Object}
  // A data object corresponding to the attributes
  // you would use in a template. Optional.
  {
    // (see details in the next section below)
  },

  // {String | Array}
  // Children VNodes, built using `createElement()`,
  // or using strings to get 'text VNodes'. Optional.
  [
    'Some text comes first.',
    createElement('h1', 'A headline'),
    createElement(MyComponent, {
      props: {
        someProp: 'foobar'
      }
    })
  ]
)
</code></pre>
<pre><code class=language-javascript>export function _createElement (
  context: Component,
  tag?: string | Class&lt;Component&gt; | Function | Object,
  data?: VNodeData,
  children?: any,
  normalizationType?: number
): VNode | Array&lt;VNode&gt; {
  if (isDef(data) &amp;&amp; isDef((data: any).__ob__)) {
    process.env.NODE_ENV !== 'production' &amp;&amp; warn(
      `Avoid using observed data object as vnode data: ${JSON.stringify(data)}\n` +
      'Always create fresh vnode data objects in each render!',
      context
    )
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) &amp;&amp; isDef(data.is)) {
    tag = data.is
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if (process.env.NODE_ENV !== 'production' &amp;&amp;
    isDef(data) &amp;&amp; isDef(data.key) &amp;&amp; !isPrimitive(data.key)
  ) {
    if (!__WEEX__ || !('@binding' in data.key)) {
      warn(
        'Avoid using non-primitive value as key, ' +
        'use string/number value instead.',
        context
      )
    }
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &amp;&amp;
    typeof children[0] === 'function'
  ) {
    data = data || {}
    data.scopedSlots = { default: children[0] }
    children.length = 0
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children)
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children)
  }
  let vnode, ns
  if (typeof tag === 'string') {
    let Ctor
    ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag)
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      )
    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag)
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      )
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children)
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) applyNS(vnode, ns)
    if (isDef(data)) registerDeepBindings(data)
    return vnode
  } else {
    return createEmptyVNode()
  }
}
</code></pre>
<p><strong>normalizeChildren</strong></p>
<pre><code class=language-javascript>if(normalizationType === ALWAYS_NORMALIZE){
    // å°†åµŒå¥—çš„ children æ•°ç»„æ‹å¹³
    children = normalizationChildren(children)
} else if (normalizationType === SIMPLE_NORMALIZE){
    // simpleNormalize å°†äºŒç»´æ•°ç»„æ‹å¹³
    children = simpleNormalizeChildren(children)
}
</code></pre>
<p>æœ€ç»ˆéƒ½æ˜¯å°† children å˜æˆç±»å‹ä¸º VNode çš„ä¸€ç»´æ•°ç»„</p>
<p><strong>vnode</strong></p>
<pre><code class=language-javascript>let vnode, ns
if (typeof tag === 'string') {
  let Ctor
  ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag)
  if (config.isReservedTag(tag)) {
    // platform built-in elements
    vnode = new VNode(
      config.parsePlatformTagName(tag), data, children,
      undefined, undefined, context
    )
  } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
    // component
    vnode = createComponent(Ctor, data, context, children, tag)
  } else {
    // unknown or unlisted namespaced elements
    // check at runtime because it may get assigned a namespace when its
    // parent normalizes children
    vnode = new VNode(
      tag, data, children,
      undefined, undefined, context
    )
  }
} else {
  // direct component options / constructor
  vnode = createComponent(tag, data, context, children)
}
</code></pre>
<p>åˆ›å»º VNode æ—¶å¯¹ tag è¿›è¡Œåˆ¤æ–­ï¼Œå¦‚æœ tag æ˜¯ string ç±»å‹è¿˜æ˜¯ Component ç±»å‹ï¼Œstring ç±»å‹ä¸‹å†åˆ¤æ–­æ˜¯å†…ç½®èŠ‚ç‚¹è¿˜æ˜¯å·²æ³¨å†Œçš„ç»„ä»¶åã€‚æ ¹æ® tag ç±»å‹å†³å®šåˆ›å»ºæ™®é€š VNode è¿˜æ˜¯ç»„ä»¶ VNodeï¼Œç»„ä»¶åˆå§‹åŒ–çš„è¿‡ç¨‹åœ¨</p>
<p><strong>update</strong></p>
<p>å›åˆ° updateComponentï¼Œåˆ›å»ºå¥½çš„ VNode è¿˜éœ€è¦é€šè¿‡ <code>vm._update</code> æ¸²æŸ“ä¸ºçœŸå® DOMã€‚<code>vm._update</code> çš„æ ¸å¿ƒæ˜¯è°ƒç”¨ <code>vm.__patch__</code> ï¼Œåœ¨é¦–æ¬¡æ¸²æŸ“å’Œæ•°æ®æ›´æ–°çš„æ—¶å€™æ‰§è¡Œ</p>
<pre><code class=language-javascript>Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
  const vm: Component = this
  const prevEl = vm.$el
  const prevVnode = vm._vnode
  const prevActiveInstance = activeInstance
  activeInstance = vm
  vm._vnode = vnode
  // Vue.prototype.__patch__ is injected in entry points
  // based on the rendering backend used.
  if (!prevVnode) {
    // initial render
    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
  } else {
    // updates
    vm.$el = vm.__patch__(prevVnode, vnode)
  }
  activeInstance = prevActiveInstance
  // update __vue__ reference
  if (prevEl) {
    prevEl.__vue__ = null
  }
  if (vm.$el) {
    vm.$el.__vue__ = vm
  }
  // if parent is an HOC, update its $el as well
  if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) {
    vm.$parent.$el = vm.$el
  }
  // updated hook is called by the scheduler to ensure that children are
  // updated in a parent's updated hook.
}
</code></pre>
<p><strong>patch ä¸å‡½æ•°æŸ¯é‡ŒåŒ–</strong></p>
<blockquote>
<p>ã€ŠMostly adequate guideã€‹æ€»ç»“å‡½æ•°æŸ¯é‡ŒåŒ–â€”â€”â€” åªä¼ é€’ç»™å‡½æ•°ä¸€éƒ¨åˆ†å‚æ•°æ¥è°ƒç”¨å®ƒï¼Œè®©å®ƒè¿”å›ä¸€ä¸ªå‡½æ•°å»å¤„ç†å‰©ä¸‹çš„å‚æ•°ï¼›æŸ¯é‡ŒåŒ–ä¸ºå®ç°å¤šå‚å‡½æ•°æä¾›äº†ä¸€ä¸ªé€’å½’é™è§£çš„å®ç°æ€è·¯â€”â€”æŠŠæ¥å—å¤šä¸ªå‚æ•°çš„å‡½æ•°å˜æ¢æˆæ¥å—ä¸€ä¸ªå•ä¸€å‚æ•°ï¼ˆæœ€åˆå‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°ï¼‰çš„å‡½æ•°ï¼Œå¹¶ä¸”è¿”å›æ¥å—ä½™ä¸‹çš„å‚æ•°è€Œä¸”è¿”å›ç»“æœçš„æ–°å‡½æ•°</p>
</blockquote>
<p>Vue.js å¯ä»¥è·¨å¹³å°è¿è¡Œï¼Œä¸åŒçš„å¹³å°æ‹¥æœ‰ä¸åŒçš„ nodeOps æ–¹æ³•å’Œmodules å±æ€§ ã€‚åˆ©ç”¨å‡½æ•°æŸ¯é‡ŒåŒ–å¯ä»¥é¿å…æ¯æ¬¡æ‰§è¡Œ patch éƒ½è¦<code>if...else...</code>åˆ¤æ–­å¹³å°æ¡ä»¶ï¼Œé€šè¿‡ <code>createPatchFunction</code> åœ¨è¿”å›çœŸæ­£çš„ patch å‡½æ•°ä¹‹å‰å°±å°†å¹³å°ä¹‹é—´çš„å·®å¼‚ä¸€æ¬¡æ€§æŠ¹å¹³</p>
<pre><code class=language-javascript>// nodeOps: æ“ä½œ DOM æ–¹æ³•
// modules: DOM å„ç±»å±æ€§ã€ç±»ã€äº‹ä»¶ã€æ ·å¼ã€é’©å­å‡½æ•°ç­‰
export const patch: Function = createPatchFunction({ nodeOps, modules})

//patch.js
export function createPatchFunction (backend){
  let i, j
  const cbs = {}

  const {modules, nodeOps } = backend

  for(i = 0; i &lt; hooks.length; ++i){
    cbs[hooks[i]] = []
    for(j = 0; j &lt; modules.length; ++j){
      if(isDef(modules[j][hooks[i]])){
        cbs[hooks[i]].push(modules[j][hooks[i]])
      }
    }
  }
  ... è¾…åŠ©å‡½æ•°
  // oldVnode: ä¸å­˜åœ¨/ä¸€ä¸ªçœŸå® DOM
  // vnode: _render æ‰§è¡Œè¿”å›çš„ VNode èŠ‚ç‚¹
  return function patch(oldVnode, vnode, hyrating, removeOnly){
    const isRealElement = isDef(oldVnode.nodeType)
    if(!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)){
      patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)
    } else {
      if(isRealElement){
        if(oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)){
          oldVnode.removeAttribute(SSR_ATTR)
          hydrating = true
        }
        if(isTrue(hydrating)){
          //...SSR
        }
        // create an empty node and replace it
        oldVnode = emptyNodeAt(oldVnode)
      }

      // replacing existing element
      const oldElm = oldVnode.elm
      const parentElm = nodeOps.parentNode(oldElm)

      createElm(
      	vnode,
        insertedVnodeQueue,
        ...,
        nodeOps.nextSibling(oldElm)
      )
    }
  }
}
</code></pre>
<p>åœ¨é¦–æ¬¡åˆå§‹åŒ–çš„æ—¶å€™ï¼Œ<code>oldVnode</code> å³ <code>vm.$el</code> å®é™…ä¸Šæ˜¯ä¸€ä¸ªå®¹å™¨ï¼Œ<code>isRealElement</code> ä¸º trueï¼Œå†é€šè¿‡ <code>empthNodeAt</code> å°† <code>oldVnode</code> è½¬æ¢ä¸º <code>VNode</code> ï¼Œæœ€åè°ƒç”¨ <code>createElm </code> åˆ›å»ºçœŸå® DOM æ’å…¥åˆ°çˆ¶èŠ‚ç‚¹ä¸­</p>
<p><strong>createElm</strong></p>
<pre><code class=language-javascript>function createElm (
	vnode,
	insertedVnodeQueue,
	parentElm,
	refElm,
	nested,
	ownerArray,
	index
){
	if(isDef(vnode.elm) &amp;&amp; isDef(ownerArray)){
		vnode = ownerArray[index] = cloneVNode(vnode)
	}
	if(createComponent(vnode, insertedVnodeQueue, parentElm, refElm)){
		return
	}

	const data = vnode.data
	const children = vnode.children
	const tag = vnode.tag
	if(isDef(tag)){
		...
	}
	// åˆ›å»ºå ä½ç¬¦å…ƒç´ 
	vnode.elm = nodeOps.createElement(tag, vnode)
	setScope(vnode)

  createChildren(vnode, children, insertedVnodeQueue)
  if(isDef(data)){
    invokeCreateHooks(vnode, insertedVnodeQueue)
  }
  insert(parentElm, vnode.elm, refElm)
}
</code></pre>
<p><strong>createChildren</strong></p>
<p><code>createChildren</code> åˆ›å»ºå­å…ƒç´ ï¼Œæ·±åº¦ä¼˜å…ˆéå†å­è™šæ‹ŸèŠ‚ç‚¹ï¼Œé€’å½’è°ƒç”¨ <code>createElm</code>ï¼Œéå†è¿‡ç¨‹ä¸­æŠŠ <code>vnode.elm</code> ä½œä¸ºçˆ¶å®¹å™¨çš„ DOM èŠ‚ç‚¹å ä½ç¬¦ä¼ å…¥</p>
<pre><code class=language-javascript>function createChildren(vnode, children, insertedVnodeQueue){
	if(Array.isArray(children)){
		if(process.env.NODE_ENV !== 'production'){
			checkDuplicateKeys(children)
		}
		for(let i = 0; i &lt; children.length; ++i){
			createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i)
		}
	} else if(isPrimitive(vnode.text)){
    nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)))
  }
}
</code></pre>
<p><strong>invokeCreateHooks</strong></p>
<p>æ‰§è¡Œæ‰€æœ‰ create é’©å­å¹¶æŠŠ <code>vnode</code> push åˆ° <code>insertedVnodeQueue</code></p>
<pre><code>function invokeCreateHooks(vnode, insertedVnodeQueue){
	for(let i = 0; i &lt; cbs.create.length; ++i){
		cbs.create[i](emptyNode, vnode)
	}
  i = vnode.data.hook	// Reuse variable
  if(isDef(i)){
    if(isDef(i.create)) i.create(emptyNode, vnode)
    if(isDef(i.insert)) insertedVnodeQueue.push(vnode)
  }
}
</code></pre>
<p><strong>insert</strong></p>
<p>æœ€ç»ˆè°ƒç”¨ <code>insert</code> æ–¹æ³•æŠŠ DOM æ’å…¥çˆ¶èŠ‚ç‚¹ï¼ŒDOM èŠ‚ç‚¹çš„æ’å…¥é¡ºåºæ˜¯å…ˆå­åçˆ¶ï¼Œç›´åˆ°æ•´ä¸ª DOM æ ‘æ’å…¥ <code>oldVnode.elm</code> çš„çˆ¶å…ƒç´  Body</p>
<pre><code class=language-javascript>function insert(parent, elm, ref){
	if(isDef(parent)){
		if(isDef(ref)){
			if(ref.parentNode === parent){
				nodeOps.insertedBefore(parent, elm, ref)
			}
		} else {
			nodeOps.appendChild(parent, elm)
		}
	}
}
</code></pre>
<p>åˆå§‹åŒ–è¿‡ç¨‹åˆ°äº†è¿™é‡Œç»ˆäºæ¸²æŸ“æˆäº†æœ€ç»ˆçš„çœŸå® DOMï¼Œå…³é”®èŠ‚ç‚¹çš„æµç¨‹å›¾å¦‚ä¸‹æ‰€ç¤ºï¼Œå…¶ä¸­ä» <code>createElement</code> å¼€å§‹å¯¹ç»„ä»¶çš„åˆå§‹åŒ–è¿‡ç¨‹åœ¨ä¸‹ç¯‡ä»‹ç»</p>
<pre><code>    +----------+ init +--------+    +---------+    +-----------------+
    | new Vue()+------&gt; $mount +----&gt; compile +----&gt; render function +--+
    +----------+      +--------+    +---------+    +-----------------+  |
                                                                        |
                                                                        |
+-----+    +-----------+     +-------+ update +-------+    +------------v--+
| DOM &lt;----+ createElm &lt;-----+ patch &lt;--------+ vnode &lt;----+ createElement |
+-----+    +-----------+     +-------+        +-------+    +---------------+

</code></pre>
</div>
</main>
</body>
</html>