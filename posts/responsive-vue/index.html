<!doctype html><html><head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<link rel=stylesheet type=text/css href=/css/bootstrap.min.css>
<link rel=stylesheet type=text/css href=/css/style.css>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/themes/prism.css>
<link rel=icon type=image/png href=/images/favicon.ico>
<link rel=icon href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%221em%22 font-size=%2280%22>ğŸŒ•</text></svg>">
<script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/components/prism-core.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/autoloader/prism-autoloader.min.js></script>
<script defer src=https://use.fontawesome.com/93f8d6d0b2.js></script>
<title>ç”µå­æœˆäº® | Vue å“åº”å¼åŸç†</title>
</head>
<body>
<header class="header fadeInTop content">
<a class=no-highlight href=/>ElectronicMoon</a>
</header>
<main class=main>
<div class="content-container fadeInTop">
<div class=content>
<h1 class=title>Vue å“åº”å¼åŸç†</h1>
<div class=post-meta>
<time datetime="2019-12-21 00:00:00 +0000 UTC">Dec 21, 2019</time>
</div>
<p>Vue.js é€šè¿‡æ•°æ®åŠ«æŒç»“åˆå‘å¸ƒè€…-è®¢é˜…è€…æ¨¡å¼çš„æ–¹å¼åŒå‘ç»‘å®šæ•°æ®ï¼Œè¿½è¸ªå¯¹è±¡ä¸­æ•°æ®çš„å˜åŒ–ï¼Œä»¥å®ç°å“åº”å¼ç³»ç»Ÿã€‚ä¸€ä¸ªå“åº”å¼ç³»ç»Ÿä¸»è¦ç”±å“åº”å¼å¯¹è±¡ã€ç›‘å¬å™¨ Observerã€ä¾èµ–æ”¶é›†å™¨ Dep å’Œè®¢é˜…è€… Watcher æ„æˆ</p>
<p>Vue.js åˆå§‹åŒ–çš„è¿‡ç¨‹æ‰§è¡Œåˆ° initData æ—¶ï¼Œæœ€åä¼šæ‰§è¡Œ <code>observe(data, true /* asRootData */)</code>ï¼Œobserve çš„ä½œç”¨å°±æ˜¯ç»™é VNode çš„å¯¹è±¡ç±»å‹æ•°æ®æ·»åŠ ä¸€ä¸ª <code>Observer</code> è§‚å¯Ÿè€…</p>
<p><strong>Observer</strong></p>
<p>Observer çš„æ„é€ å‡½æ•°å°†å¯¹è±¡ value æŒ‡å‘è‡ªèº«ï¼Œå®ä¾‹åŒ–ä¸€ä¸ª Depï¼Œå†æŠŠè‡ªèº«å®ä¾‹æ·»åŠ åˆ°æ•°æ®å¯¹è±¡ <code>value</code> çš„ <code>__ob__</code> å±æ€§ä¸Šï¼Œæœ€åå¦‚æœé‡åˆ°æ•°ç»„å°±éå†æ•°ç»„æ‰§è¡Œ observeï¼Œé‡åˆ°çº¯å¯¹è±¡å°±éå†å¯¹è±¡çš„ key è°ƒç”¨ <code>defineReactive</code> æ–¹æ³•</p>
<pre><code class=language-javascript>/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
export class Observer {
  value: any;
  dep: Dep;
  vmCount: number; // number of vms that has this object as root $data

  constructor (value: any) {
    this.value = value
    this.dep = new Dep()
    this.vmCount = 0
    def(value, '__ob__', this)
    if (Array.isArray(value)) {
      const augment = hasProto
        ? protoAugment
        : copyAugment
      augment(value, arrayMethods, arrayKeys)
      this.observeArray(value)
    } else {
      this.walk(value)
    }
  }

  /**
   * Walk through each property and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i &lt; keys.length; i++) {
      defineReactive(obj, keys[i])
    }
  }

  /**
   * Observe a list of Array items.
   */
  observeArray (items: Array&lt;any&gt;) {
    for (let i = 0, l = items.length; i &lt; l; i++) {
      observe(items[i])
    }
  }
}
</code></pre>
<p><strong>defineReactive</strong></p>
<pre><code class=language-javascript>/**
 * Define a reactive property on an Object.
 */
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  const dep = new Dep()

  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property &amp;&amp; property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  const getter = property &amp;&amp; property.get
  const setter = property &amp;&amp; property.set
  if ((!getter || setter) &amp;&amp; arguments.length === 2) {
    val = obj[key]
  }

  let childOb = !shallow &amp;&amp; observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        dep.depend()
        if (childOb) {
          childOb.dep.depend()
          if (Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) {
        customSetter()
      }
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = !shallow &amp;&amp; observe(newVal)
      dep.notify()
    }
  })
}
</code></pre>
<p><code>defineReactive</code> ç»™ data çš„æ¯ä¸€é¡¹æ•°æ®éƒ½å®ä¾‹åŒ–ä¸€ä¸ª Depï¼Œå¯¹å­å¯¹è±¡é€’å½’è°ƒç”¨ observeï¼ŒæŠŠ data å¯¹è±¡å®Œå…¨è½¬æ¢ä¸ºå“åº”å¼å¯¹è±¡ï¼Œæœ€åé€šè¿‡ <code>Object.defineProperty()</code> ç»™ <code>obj</code> çš„å±æ€§ <code>key</code> æ·»åŠ  getter å’Œ setter</p>
<p><strong>Dep</strong></p>
<p>æ¯ä¸€ä¸ªæ•°æ®é¡¹æŒæœ‰ Dep æ”¶é›†ä¾èµ–ï¼Œè¿™æ ·æ•°æ®æ‰èƒ½çŸ¥é“å“ªäº›åœ°æ–¹éœ€è¦å“åº”å˜åŒ–</p>
<pre><code class=language-javascript>// é€šè¿‡ Dep è§£è€¦å±æ€§çš„ä¾èµ–å’Œæ›´æ–°æ“ä½œ
export default class Dep {
  static target: ?Watcher;
  id: number;
  subs: Array&lt;Watcher&gt;;

  constructor () {
    this.id = uid++
    this.subs = []
  }

  addSub (sub: Watcher) {
    this.subs.push(sub)
  }

  removeSub (sub: Watcher) {
    remove(this.subs, sub)
  }

  depend () {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }

  notify () {
    // stabilize the subscriber list first
    const subs = this.subs.slice()
    for (let i = 0, l = subs.length; i &lt; l; i++) {
      subs[i].update()
    }
  }
}

// å› ä¸ºåªåœ¨è®¢é˜…è€…åˆå§‹åŒ–æ—¶æ‰éœ€è¦æ·»åŠ ï¼Œé€šè¿‡å…¨å±€å±æ€§ target ç¼“å­˜ Watcherï¼Œæ·»åŠ æˆåŠŸåå»é™¤
Dep.target = null;
</code></pre>
<p>Vue ç»„ä»¶æŒ‚è½½çš„æ—¶å€™ä¼šå…ˆå¯¹æ‰€æœ‰éœ€è¦çš„å±æ€§è°ƒç”¨ <code>Object.defineProperty()</code>,å†å®ä¾‹åŒ– <code>Watcher</code>ï¼Œä¼ å…¥ç»„ä»¶æ›´æ–°çš„å›è°ƒã€‚åœ¨å®ä¾‹åŒ–è¿‡ç¨‹ä¸­ï¼Œä¼šå¯¹æ¨¡æ¿ä¸­çš„å±æ€§è¿›è¡Œæ±‚å€¼ï¼Œè§¦å‘ä¾èµ–æ”¶é›†ã€‚</p>
<p><strong>Watcher</strong></p>
<pre><code>updateComponent = () =&gt; {
  vm._update(vm._render(), hydrating)
}
new Watcher(vm, updateComponent, noop, {
  before () {
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate')
    }
  }
}, true /* isRenderWatcher */)
</code></pre>
<p>æ¯ä¸€ä¸ª vm å®ä¾‹åœ¨æŒ‚è½½çš„è¿‡ç¨‹ä¸­ä¼šå®ä¾‹åŒ–ä¸€ä¸ªæ¸²æŸ“ Watcherï¼Œå®ƒä¼šåœ¨ç»„ä»¶æ¸²æŸ“çš„è¿‡ç¨‹ä¸­æŠŠâ€œæ¥è§¦â€è¿‡çš„æ•°æ®å±æ€§è®°å½•ä¸ºä¾èµ–</p>
<pre><code class=language-javascript>/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
export default class Watcher {
  vm: Component;
  expression: string;
  cb: Function;
  id: number;
  deep: boolean;
  user: boolean;
  computed: boolean;
  sync: boolean;
  dirty: boolean;
  active: boolean;
  dep: Dep;
  deps: Array&lt;Dep&gt;;
  newDeps: Array&lt;Dep&gt;;
  depIds: SimpleSet;
  newDepIds: SimpleSet;
  before: ?Function;
  getter: Function;
  value: any;

  constructor (
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: ?Object,
    isRenderWatcher?: boolean
  ) {
    this.vm = vm
    if (isRenderWatcher) {
      vm._watcher = this
    }
    vm._watchers.push(this)
    // options
    if (options) {
      this.deep = !!options.deep
      this.user = !!options.user
      this.computed = !!options.computed
      this.sync = !!options.sync
      this.before = options.before
    } else {
      this.deep = this.user = this.computed = this.sync = false
    }
    this.cb = cb
    this.id = ++uid // uid for batching
    this.active = true
    this.dirty = this.computed // for computed watchers
    this.deps = []
    this.newDeps = []
    this.depIds = new Set()
    this.newDepIds = new Set()
    this.expression = process.env.NODE_ENV !== 'production'
      ? expOrFn.toString()
      : ''
    // parse expression for getter
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn
    } else {
      this.getter = parsePath(expOrFn)
      if (!this.getter) {
        this.getter = function () {}
        process.env.NODE_ENV !== 'production' &amp;&amp; warn(
          `Failed watching path: &quot;${expOrFn}&quot; ` +
          'Watcher only accepts simple dot-delimited paths. ' +
          'For full control, use a function instead.',
          vm
        )
      }
    }
    if (this.computed) {
      this.value = undefined
      this.dep = new Dep()
    } else {
      this.value = this.get()
    }
  }

  /**
   * Evaluate the getter, and re-collect dependencies.
   */
  get () {
    pushTarget(this)
    let value
    const vm = this.vm
    try {
      value = this.getter.call(vm, vm)
    } catch (e) {
      if (this.user) {
        handleError(e, vm, `getter for watcher &quot;${this.expression}&quot;`)
      } else {
        throw e
      }
    } finally {
      // &quot;touch&quot; every property so they are all tracked as
      // dependencies for deep watching
      if (this.deep) {
        traverse(value)
      }
      popTarget()
      this.cleanupDeps()
    }
    return value
  }

  /**
   * Add a dependency to this directive.
   */
  addDep (dep: Dep) {
    const id = dep.id
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id)
      this.newDeps.push(dep)
      if (!this.depIds.has(id)) {
        dep.addSub(this)
      }
    }
  }

  /**
   * Clean up for dependency collection.
   */
  cleanupDeps () {
    let i = this.deps.length
    while (i--) {
      const dep = this.deps[i]
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this)
      }
    }
    let tmp = this.depIds
    this.depIds = this.newDepIds
    this.newDepIds = tmp
    this.newDepIds.clear()
    tmp = this.deps
    this.deps = this.newDeps
    this.newDeps = tmp
    this.newDeps.length = 0
  }
  // ...
}
</code></pre>
<p>Watcher åœ¨å®ä¾‹åŒ–è¿‡ç¨‹ä¸­æ‰§è¡Œ <code>this.get()</code>ï¼Œå…¶å†…éƒ¨é¦–å…ˆæ‰§è¡Œ pushTargetï¼Œ<code>pushTarget</code> å°†å½“å‰ Watcher å‹æ ˆï¼Œå¹¶å°†æ–°ç”Ÿæˆçš„ Watcher æŒ‡å‘ <code>Dep.target</code></p>
<pre><code class=language-javascript>export function pushTarget (_target: Watcher) {
  if (Dep.target) targetStack.push(Dep.target)
  Dep.target = _target
}
</code></pre>
<p>æ¥ç€æ‰§è¡Œ <code>value = this.getter.call(vm, vm)</code> è§¦å‘ vm æ•°æ®å¯¹è±¡çš„ getterï¼Œè€Œå¯¹è±¡ä¸­æŒæœ‰çš„ dep å°±ä¼šåœ¨è§¦å‘ getter æ—¶è°ƒç”¨ <code>dep.depend()</code> æ–¹æ³•ï¼Œå³æ‰§è¡Œ <code>Dep.target.addDep(this)</code> æŠŠå½“å‰çš„ <code>watcher</code> æ·»åŠ åˆ°è¿™ä¸ªæ•°æ®æŒæœ‰çš„ <code>dep</code> çš„ <code>subs</code> ä¸­ï¼Œåœ¨åç»­æ•°æ®å˜åŒ–æ—¶å°†å‘ subs ä¸­çš„è®¢é˜…è€…å‘å¸ƒé€šçŸ¥</p>
<pre><code class=language-javascript>addDep (dep: Dep) {
  const id = dep.id
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id)
    this.newDeps.push(dep)
    if (!this.depIds.has(id)) {
      dep.addSub(this)
    }
  }
}
</code></pre>
<p>å¦‚æœç”¨æˆ·è®¾ç½®<code>deep Watcher</code>ï¼ŒVue.js è¿˜ä¼šæ·±åº¦è§¦åŠæ‰€æœ‰çš„å­å±æ€§çš„ getter</p>
<pre><code>if(this.deep){
	traverse(value)
}
</code></pre>
<p>æ¥ç€å°†ä¹‹å‰å‹æ ˆçš„ Watcher æ¢å¤æŒ‡å‘ <code>Dep.target</code> ï¼Œç”±äºé€’å½’è°ƒç”¨ï¼ŒWatcher çš„å®ä¾‹åŒ–å…ˆçˆ¶åå­ï¼Œè€Œè®¡ç®—æ”¶é›†ä¾èµ–æ˜¯å…ˆå­åçˆ¶</p>
<pre><code>function popTarget () {
  targetStack.pop()
  Dep.target = targetStack[targetStack.length - 1]
}
</code></pre>
<p>æœ€åæ¸…ç©ºä¾èµ–</p>
<pre><code class=language-javascript>cleanupDeps () {
  let i = this.deps.length
  while (i--) {
    const dep = this.deps[i]
    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this)
    }
  }
  let tmp = this.depIds
  this.depIds = this.newDepIds
  this.newDepIds = tmp
  this.newDepIds.clear()
  tmp = this.deps
  this.deps = this.newDeps
  this.newDeps = tmp
  this.newDeps.length = 0
}
</code></pre>
<p>ç”±äºæ¯æ¬¡æ•°æ®å˜åŒ–éƒ½ä¼šé‡æ–°æ‰§è¡Œ <code>vm._render()</code>ï¼Œå†æ¬¡è§¦å‘æ•°æ®çš„ gettersï¼Œæ‰€ä»¥æ¸²æŸ“ <code>Watcher</code> åœ¨æ„é€ å‡½æ•°ä¸­ä¼šåˆå§‹åŒ– 2 ä¸ª <code>Dep</code> å®ä¾‹æ•°ç»„ï¼Œ<code>newDeps</code> è¡¨ç¤ºæ–°æ·»åŠ çš„ <code>Dep</code> å®ä¾‹æ•°ç»„ï¼Œ <code>deps</code> è¡¨ç¤ºä¸Šä¸€æ¬¡æ·»åŠ çš„ <code>Dep</code> å®ä¾‹æ•°ç»„ã€‚ä¸ºäº†é¿å…é‡æ–°æ¸²æŸ“æ—¶çš„é€šçŸ¥æµªè´¹ï¼Œåœ¨æ¯æ¬¡é‡æ–°æ”¶é›†ä¾èµ–ç»“æŸï¼Œéœ€è¦éå† <code>deps</code> æ¸…ç©ºè®¢é˜…ï¼Œå¹¶å°† <code>newDeps</code> å’Œ <code>deps</code> äº¤æ¢ã€‚</p>
<p><strong>update()</strong></p>
<p>æ•°æ®æ›´æ–°è§¦å‘ setterï¼Œè°ƒç”¨ <code>dep.notify()</code></p>
<pre><code class=language-javascript>class Dep{
	notify(){
	// stabilize the subscriber list first
		const subs = this.subs.slice()
		for(let i = 0, l = subs.length; i &lt; l; i++){
			subs[i].update()
		}
	}
}
</code></pre>
<p>åœ¨æ´¾å‘é€šçŸ¥çš„è¿‡ç¨‹ä¸­ï¼Œsubs æ•°ç»„å¯èƒ½ä»åœ¨å‘ç”Ÿå˜åŠ¨ï¼Œæ‰€ä»¥ç¬¬ä¸€æ­¥å…ˆå›ºå®šè®¢é˜…åˆ—è¡¨ï¼Œç¬¬äºŒæ­¥éå†æ•°ç»„é¡¹è°ƒç”¨ Watcher çš„ update æ–¹æ³•</p>
<pre><code class=language-javascript>class Watcher {
  // ...
  update () {
    /* istanbul ignore else */
    if (this.computed) {
      // A computed property watcher has two modes: lazy and activated.
      // It initializes as lazy by default, and only becomes activated when
      // it is depended on by at least one subscriber, which is typically
      // another computed property or a component's render function.
      if (this.dep.subs.length === 0) {
        // In lazy mode, we don't want to perform computations until necessary,
        // so we simply mark the watcher as dirty. The actual computation is
        // performed just-in-time in this.evaluate() when the computed property
        // is accessed.
        this.dirty = true
      } else {
        // In activated mode, we want to proactively perform the computation
        // but only notify our subscribers when the value has indeed changed.
        this.getAndInvoke(() =&gt; {
          this.dep.notify()
        })
      }
    } else if (this.sync) {
      this.run()
    } else {
      queueWatcher(this)
    }
  }
}
</code></pre>
<p>æœ€åç»„ä»¶æ•°æ®æ›´æ–°ä¼šæ‰§è¡Œ <code>queueWatcher(this)</code> å¼€å¯ Watcher é˜Ÿåˆ—</p>
<pre><code class=language-javascript>const queue: Array&lt;Watcher&gt; = []
let has: { [key: number]: ?true } = {}
let waiting = false
let flushing = false
/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
export function queueWatcher (watcher: Watcher) {
  const id = watcher.id
  if (has[id] == null) {
    has[id] = true
    if (!flushing) {
      queue.push(watcher)
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      let i = queue.length - 1
      while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) {
        i--
      }
      queue.splice(i + 1, 0, watcher)
    }
    // queue the flush
    if (!waiting) {
      waiting = true
      nextTick(flushSchedulerQueue)
    }
  }
}
</code></pre>
<p>Vue.js ä¸ä¼šæ¯æ¬¡æ•°æ®æ”¹å˜éƒ½ä¼šè§¦å‘ Watcher å›è°ƒï¼Œè€Œæ˜¯å°† Watcher æ·»åŠ åˆ° <code>queue</code> é˜Ÿåˆ—ï¼Œåœ¨ <code>nextTick</code> åå¼‚æ­¥æ‰§è¡Œ <code>flushSchedulerQueue</code></p>
<pre><code class=language-javascript>let flushing = false
let index = 0
/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  flushing = true
  let watcher, id

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort((a, b) =&gt; a.id - b.id)

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index &lt; queue.length; index++) {
    watcher = queue[index]
    if (watcher.before) {
      watcher.before()
    }
    id = watcher.id
    has[id] = null
    watcher.run()
    // in dev build, check and stop circular updates.
    if (process.env.NODE_ENV !== 'production' &amp;&amp; has[id] != null) {
      circular[id] = (circular[id] || 0) + 1
      if (circular[id] &gt; MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? `in watcher with expression &quot;${watcher.expression}&quot;`
              : `in a component render function.`
          ),
          watcher.vm
        )
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  const activatedQueue = activatedChildren.slice()
  const updatedQueue = queue.slice()

  resetSchedulerState()

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue)
  callUpdatedHooks(updatedQueue)

  // devtool hook
  /* istanbul ignore if */
  if (devtools &amp;&amp; config.devtools) {
    devtools.emit('flush')
  }
}
</code></pre>
<p>å…¶ä¸­ <code>queue.sort((a, b) => a.id - b.id)</code> å¯¹é˜Ÿåˆ—åšæ’åºï¼Œç¡®ä¿ç»„ä»¶æ›´æ–°é¡ºåºä»çˆ¶åˆ°å­ï¼Œä»ç”¨æˆ· Watcher åˆ°æ¸²æŸ“ Watcherã€‚æ’åºåéå†é˜Ÿåˆ—æ‹¿åˆ°å¯¹åº” Watcher æ‰§è¡Œ <code>watcher.run()</code></p>
<pre><code class=language-javascript>class Watcher {
  /**
   * Scheduler job interface.
   * Will be called by the scheduler.
   */
  run () {
    if (this.active) {
      this.getAndInvoke(this.cb)
    }
  }

  getAndInvoke (cb: Function) {
    const value = this.get()
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      const oldValue = this.value
      this.value = value
      this.dirty = false
      if (this.user) {
        try {
          cb.call(this.vm, value, oldValue)
        } catch (e) {
          handleError(e, this.vm, `callback for watcher &quot;${this.expression}&quot;`)
        }
      } else {
        cb.call(this.vm, value, oldValue)
      }
    }
  }
}
</code></pre>
<p><code>watcher.run()</code> æ‰§è¡Œ <code>this.get()</code> è·å–å½“å‰çš„æ›´æ–°å€¼ï¼Œæ»¡è¶³æ¡ä»¶æ‰§è¡Œ <code>watcher</code> å›è°ƒï¼Œè§¦å‘ç»„ä»¶é‡æ–°æ¸²æŸ“</p>
<p>ä»¥ä¸Š Vue.js åœ¨åˆå§‹åŒ–æ•°æ®æ—¶å¦‚ä½•å°†æ•°æ®å¯¹è±¡è½¬æ¢æˆå“åº”å¼å¯¹è±¡ä»¥åŠå¦‚ä½•ç»‘å®šæ•°æ®å’Œè®¢é˜…è€…ä¹‹é—´çš„ä¾èµ–å…³ç³»ï¼Œåœ¨æ•°æ®å˜åŒ–æ—¶å¦‚ä½•å°†æ›´æ–°æ´¾å‘ç»™è®¢é˜…è€…å¹¶é‡æ–°è§¦å‘æ¸²æŸ“ã€‚ç°åœ¨æˆ‘ä»¬å…³æ³¨ Vue.js æ€ä¹ˆå¼‚æ­¥æ›´æ–° DOMï¼Œå†…éƒ¨å¦‚ä½•å®ç°å¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ—</p>
<h3 id=event-loop>Event Loop</h3>
<p>äº‹ä»¶å¾ªç¯æœºåˆ¶å’Œæ¶ˆæ¯é˜Ÿåˆ— çš„ç»´æŠ¤ç”±äº‹ä»¶è§¦å‘çº¿ç¨‹æ§åˆ¶çš„ï¼Œäº‹ä»¶è§¦å‘çº¿ç¨‹åŒæ—¶ç»´æŠ¤ä¸€ä¸ª æ¶ˆæ¯é˜Ÿåˆ—ï¼ŒJS å¼•æ“çº¿ç¨‹é‡åˆ°å¼‚æ­¥ä»»åŠ¡ï¼ˆDOM äº‹ä»¶ç›‘å¬ã€ç½‘ç»œè¯·æ±‚ã€setTimeout è®¡æ—¶å™¨ç­‰&mldr;ï¼‰ï¼Œä¼šäº¤ç»™ç›¸åº”çš„çº¿ç¨‹å•ç‹¬å»ç»´æŠ¤ï¼Œç­‰å¾…æŸä¸ªæ—¶æœºï¼ˆè®¡æ—¶å™¨ç»“æŸã€ç½‘ç»œè¯·æ±‚æˆåŠŸã€ç”¨æˆ·ç‚¹å‡» DOMï¼‰ï¼Œç„¶åç”±äº‹ä»¶è§¦å‘çº¿ç¨‹å°†å¼‚æ­¥å¯¹åº”çš„ å›è°ƒå‡½æ•° åŠ å…¥åˆ°æ¶ˆæ¯é˜Ÿåˆ—ä¸­ï¼Œæ¶ˆæ¯é˜Ÿåˆ—ä¸­çš„å›è°ƒå‡½æ•°ç­‰å¾…è¢«æ‰§è¡Œã€‚</p>
<p>åŒæ—¶ï¼ŒJS å¼•æ“çº¿ç¨‹ä¼šç»´æŠ¤ä¸€ä¸ªæ‰§è¡Œæ ˆï¼ŒåŒæ­¥ä»£ç ä¼šä¾æ¬¡åŠ å…¥æ‰§è¡Œæ ˆç„¶åæ‰§è¡Œï¼Œç»“æŸä¼šé€€å‡ºæ‰§è¡Œæ ˆã€‚å¦‚æœæ‰§è¡Œæ ˆé‡Œçš„ä»»åŠ¡æ‰§è¡Œå®Œæˆï¼Œå³æ‰§è¡Œæ ˆä¸ºç©ºçš„æ—¶å€™ï¼ˆå³ JS å¼•æ“çº¿ç¨‹ç©ºé—²ï¼‰ï¼Œäº‹ä»¶è§¦å‘çº¿ç¨‹æ‰ä¼šä»æ¶ˆæ¯é˜Ÿåˆ—å–å‡ºä¸€ä¸ªä»»åŠ¡ï¼ˆå³å¼‚æ­¥çš„å›è°ƒå‡½æ•°ï¼‰æ”¾å…¥æ‰§è¡Œæ ˆä¸­æ‰§è¡Œã€‚æ‰§è¡Œå®Œäº†åï¼Œæ‰§è¡Œæ ˆå†æ¬¡ä¸ºç©ºï¼Œäº‹ä»¶è§¦å‘çº¿ç¨‹ä¼šé‡å¤ä¸Šä¸€æ­¥æ“ä½œï¼Œå†å–å‡ºä¸€ä¸ªæ¶ˆæ¯é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ã€‚</p>
<p>ä¸»çº¿ç¨‹çš„æ‰§è¡Œè¿‡ç¨‹å°±æ˜¯ä¸€ä¸ª tickï¼Œè€Œæ‰€æœ‰çš„å¼‚æ­¥ç»“æœéƒ½æ˜¯é€šè¿‡ â€œä»»åŠ¡é˜Ÿåˆ—â€ æ¥è°ƒåº¦ã€‚ æ¶ˆæ¯é˜Ÿåˆ—ä¸­å­˜æ”¾çš„æ˜¯ä»»åŠ¡ï¼ˆtaskï¼‰ï¼Œtask åˆ†ä¸º Marcotasks å’Œ Microtasksï¼Œå¾®ä»»åŠ¡ä¸ºåœ¨å½“å‰æ­£åœ¨æ‰§è¡Œçš„è„šæœ¬ä¹‹åç«‹å³å‘ç”Ÿçš„äº‹æƒ…å®‰æ’ï¼Œå¾®ä»»åŠ¡åœ¨æ¯ä¸€ä¸ªå®ä»»åŠ¡ç»“æŸåæ¸…ç©º</p>
<pre><code>for (macroTask of macroTaskQueue) {
    // 1. Handle current MACRO-TASK
    handleMacroTask();

    // 2. Handle all MICRO-TASK
    for (microTask of microTaskQueue) {
        handleMicroTask(microTask);
    }
}
</code></pre>
<p><strong>nextTick</strong></p>
<p>Vue åœ¨å†…éƒ¨å¯¹å¼‚æ­¥é˜Ÿåˆ—å°è¯•ä½¿ç”¨åŸç”Ÿçš„ <code>Promise.then</code>ã€<code>MutationObserver</code> å’Œ <code>setImmediate</code>ï¼Œå¦‚æœæ‰§è¡Œç¯å¢ƒä¸æ”¯æŒï¼Œåˆ™ä¼šé‡‡ç”¨ <code>setTimeout(fn, 0)</code> ä»£æ›¿</p>
<pre><code class=language-javascript>import { noop } from 'shared/util'
import { handleError } from './error'
import { isIOS, isNative } from './env'

const callbacks = []
let pending = false

function flushCallbacks () {
  pending = false
  const copies = callbacks.slice(0)
  callbacks.length = 0
  for (let i = 0; i &lt; copies.length; i++) {
    copies[i]()
  }
}

// Here we have async deferring wrappers using both microtasks and (macro) tasks.
// In &lt; 2.4 we used microtasks everywhere, but there are some scenarios where
// microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690) or even between bubbling of the same
// event (#6566). However, using (macro) tasks everywhere also has subtle problems
// when state is changed right before repaint (e.g. #6813, out-in transitions).
// Here we use microtask by default, but expose a way to force (macro) task when
// needed (e.g. in event handlers attached by v-on).
let microTimerFunc
let macroTimerFunc
let useMacroTask = false

// Determine (macro) task defer implementation.
// Technically setImmediate should be the ideal choice, but it's only available
// in IE. The only polyfill that consistently queues the callback after all DOM
// events triggered in the same loop is by using MessageChannel.
/* istanbul ignore if */
if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) {
  macroTimerFunc = () =&gt; {
    setImmediate(flushCallbacks)
  }
} else if (typeof MessageChannel !== 'undefined' &amp;&amp; (
  isNative(MessageChannel) ||
  // PhantomJS
  MessageChannel.toString() === '[object MessageChannelConstructor]'
)) {
  const channel = new MessageChannel()
  const port = channel.port2
  channel.port1.onmessage = flushCallbacks
  macroTimerFunc = () =&gt; {
    port.postMessage(1)
  }
} else {
  /* istanbul ignore next */
  macroTimerFunc = () =&gt; {
    setTimeout(flushCallbacks, 0)
  }
}

// Determine microtask defer implementation.
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) {
  const p = Promise.resolve()
  microTimerFunc = () =&gt; {
    p.then(flushCallbacks)
    // in problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // &quot;force&quot; the microtask queue to be flushed by adding an empty timer.
    if (isIOS) setTimeout(noop)
  }
} else {
  // fallback to macro
  microTimerFunc = macroTimerFunc
}

/**
 * Wrap a function so that if any code inside triggers state change,
 * the changes are queued using a (macro) task instead of a microtask.
 */
export function withMacroTask (fn: Function): Function {
  return fn._withTask || (fn._withTask = function () {
    useMacroTask = true
    const res = fn.apply(null, arguments)
    useMacroTask = false
    return res
  })
}

export function nextTick (cb?: Function, ctx?: Object) {
  let _resolve
  callbacks.push(() =&gt; {
    if (cb) {
      try {
        cb.call(ctx)
      } catch (e) {
        handleError(e, ctx, 'nextTick')
      }
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  if (!pending) {
    pending = true
    if (useMacroTask) {
      macroTimerFunc()
    } else {
      microTimerFunc()
    }
  }
  // $flow-disable-line
  if (!cb &amp;&amp; typeof Promise !== 'undefined') {
    return new Promise(resolve =&gt; {
      _resolve = resolve
    })
  }
}
</code></pre>
<p>nextTick å†…éƒ¨å£°æ˜ <code>microTimerFunc</code> å’Œ <code>macroTimerFunc</code> å˜é‡åˆ†åˆ«å®ç° <code>microTasks</code> å’Œ <code>macroTasks</code>ï¼Œä¸”ä»–ä»¬éƒ½ä¼šåœ¨ä¸‹ä¸€ä¸ª tick æ‰§è¡Œ <code>flushCallbacks</code>ï¼Œ<code>flushCallbacks</code> åˆ™éå†æ‰§è¡Œ callbacks æ•°ç»„</p>
<p>å¦‚æœä¸ä¼  cbï¼Œ<code>nextTick()</code> è¿”å›ä¸€ä¸ª Promise</p>
<pre><code class=language-javascript>methods: {
  updateMessage: async function () {
    this.message = 'å·²æ›´æ–°'
    console.log(this.$el.textContent) // =&gt; 'æœªæ›´æ–°'
    await this.$nextTick()
    console.log(this.$el.textContent) // =&gt; 'å·²æ›´æ–°'
  }
}
</code></pre>
<p><strong>Vue.set</strong></p>
<p>ç”±äº <code>Object.defineProperty</code> çš„é™åˆ¶ï¼Œç»™å¯¹è±¡æ·»åŠ æ–°çš„å±æ€§ä¸èƒ½è§¦å‘å®ƒçš„ setterã€‚ä½¿ç”¨å…¨å±€çš„ API <code>Vue.set</code>ï¼Œå‘å“åº”å¼å¯¹è±¡ä¸­æ·»åŠ ä¸€ä¸ªå±æ€§ï¼Œå¹¶ç¡®ä¿è¿™ä¸ªæ–°å±æ€§åŒæ ·æ˜¯å“åº”å¼çš„ï¼Œä¸”è§¦å‘è§†å›¾æ›´æ–°</p>
<pre><code class=language-javascript>function set (target: Array&lt;any&gt; | Object, key: any, val: any): any {
  if (process.env.NODE_ENV !== 'production' &amp;&amp;
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(`Cannot set reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }
  if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    return val
  }
  if (key in target &amp;&amp; !(key in Object.prototype)) {
    target[key] = val
    return val
  }
  const ob = (target: any).__ob__
  if (target._isVue || (ob &amp;&amp; ob.vmCount)) {
    process.env.NODE_ENV !== 'production' &amp;&amp; warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    )
    return val
  }
  if (!ob) {
    target[key] = val
    return val
  }
  defineReactive(ob.value, key, val)
  ob.dep.notify()
  return val
}
</code></pre>
<p><code>set</code> å‡½æ•°åœ¨ä¸€ç³»åˆ—åˆ¤æ–­æ¡ä»¶åè·å– <code>target.__ob__</code> å³å“åº”å¼å¯¹è±¡çš„ Observerï¼Œé€šè¿‡ <code>defineReactive(ob.value, key, val)</code> å°†æ–°å¢å±æ€§å˜æˆå“åº”å¼ï¼Œæœ€åæ‰‹åŠ¨<code>ob.dep.notify()</code> è§¦å‘æ›´æ–°ï¼Œè¿™é‡Œèƒ½å¤Ÿè®©æ–°å¢çš„å±æ€§ä¹Ÿèƒ½æ´¾å‘æ›´æ–°å¾—ç›Šäºåœ¨åˆå§‹åŒ–è¿‡ç¨‹ä¸­å¯¹ <code>childOb</code> çš„æ·±åº¦ç»‘å®šä¾èµ–</p>
<pre><code class=language-javascript>if (childOb) {
  childOb.dep.depend()
  if (Array.isArray(value)) {
    dependArray(value)
  }
}
</code></pre>
</div>
</main>
</body>
</html>