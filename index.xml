<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>电子月亮</title><link>https://electronicmoon.space/</link><description>Recent content on 电子月亮</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 21 Dec 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://electronicmoon.space/index.xml" rel="self" type="application/rss+xml"/><item><title>Vue 响应式原理</title><link>https://electronicmoon.space/posts/responsive-vue/</link><pubDate>Sat, 21 Dec 2019 00:00:00 +0000</pubDate><guid>https://electronicmoon.space/posts/responsive-vue/</guid><description>Vue.js 通过数据劫持结合发布者-订阅者模式的方式双向绑定数据，追踪对象中数据的变化，以实现响应式系统。一个响应式系统主要由响应式对象、监听器 Observer、依赖收集器 Dep 和订阅者 Watcher 构成
Vue.js 初始化的过程执行到 initData 时，最后会执行 observe(data, true /* asRootData */)，observe 的作用就是给非 VNode 的对象类型数据添加一个 Observer 观察者
Observer
Observer 的构造函数将对象 value 指向自身，实例化一个 Dep，再把自身实例添加到数据对象 value 的 __ob__ 属性上，最后如果遇到数组就遍历数组执行 observe，遇到纯对象就遍历对象的 key 调用 defineReactive 方法
/** * Observer class that is attached to each observed * object. Once attached, the observer converts the target * object's property keys into getter/setters that * collect dependencies and dispatch updates. */ export class Observer { value: any; dep: Dep; vmCount: number; // number of vms that has this object as root $data constructor (value: any) { this.</description></item><item><title>Vue 初始化：从 createElement 到 Component Tree</title><link>https://electronicmoon.space/posts/vue-component/</link><pubDate>Thu, 19 Dec 2019 00:00:00 +0000</pubDate><guid>https://electronicmoon.space/posts/vue-component/</guid><description>本文介绍 Vue 组件的初始化过程
createComponent
在 _createElement 方法中，程序对参数 tag 进行判断，如果是一个原生的标签，就会按上文的分析生成一个普通的 VNode 节点；如果是一个已注册的组件名，就会走到 createComponent 创建一个组件 VNode
export function createComponent( Ctor: Class&amp;lt;Component&amp;gt; | Function | Object | void, data: ?VNodeData, context: Component, children: ?Array&amp;lt;VNode&amp;gt;, tag?: string ): VNode | Array&amp;lt;VNode&amp;gt; | void{ // baseCtor 指向 Vue const baseCtor = context.$options._base if(isObject(Ctor)){ Ctor = baseCtor.extend(Ctor) } // async component let asyncFactory if(isUndef(Ctor.cid)){ asyncFactor = Ctor Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context) if(Ctor === undefined){ return createAsyncPlaceholder(.</description></item><item><title>Vue 初始化：从 new Vue(...) 到 DOM Tree</title><link>https://electronicmoon.space/posts/new-vue/</link><pubDate>Wed, 18 Dec 2019 00:00:00 +0000</pubDate><guid>https://electronicmoon.space/posts/new-vue/</guid><description>这篇文章将从我自己的理解描述一个 Vue.js 项目是怎么从零开始初始化的主线过程，以关键函数的调用栈为线索，会略过很多繁琐的段落，分析 Vue.js 在初始化过程中的关键节点，我觉得阅读源码不能像看小说那样，线性地追寻无限的细节，而是在脑海中建立关键节点的索引和核心原理的理解，这样在需要回头具体分析某一处或者对哪部分感兴趣的时候就可以快速定位到
构造函数初始化 一个 Vue.js 应用由一个根实例和可嵌套的组件树构成，而组件都是可复用的 Vue 实例，可以从入口文件 entry-runtime-with-compiler.js -&amp;gt; runtime/index.js -&amp;gt; core/index.js -&amp;gt; instance/index.js 这条线找到 Vue 构造函数
import { initMixin } from './init' import { stateMixin } from './state' import { renderMixin } from './render' import { eventsMixin } from './events' import { lifecycleMixin } from './lifecycle' import { warn } from '../util/index' function Vue (options) { if (process.env.NODE_ENV !== 'production' &amp;amp;&amp;amp; !(this instanceof Vue) ) { warn('Vue is a constructor and should be called with the `new` keyword') } this.</description></item><item><title>UnderScore: 函数</title><link>https://electronicmoon.space/posts/underscore-function/</link><pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate><guid>https://electronicmoon.space/posts/underscore-function/</guid><description>上下文绑定 underscore 提供绑定函数上下文的方法 _.bind 和 _.bindAll，二者的绑定上下文及执行过程都由内部函数 executeBound 负责
// 执行绑定后的函数 var executeBound = function(sourceFunc, boundFunc, context, callingContext, args){ if(!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args) var self = baseCreate(sourceFunc, prototype) var result = sourceFunc.apply(self, args) if(_.isObject(result)) return result return self } executeBound 也考虑了当绑定后的函数 boundFunc 作为构造函数被 new 运算的情形，进行了执行上下文的修正。另外为了支持链式调用，所以有以下语句：
var result = sourceFunc.apply(self, args) if(_.isObject(result)) return result return self _.bind(func, context) 将 func 的执行上下文绑定到 context
_.bind = function(func, context){ if(nativeBind &amp;amp;&amp;amp; func.</description></item><item><title>UnderScore: 集合</title><link>https://electronicmoon.space/posts/underscore-collection/</link><pubDate>Tue, 19 Mar 2019 00:00:00 +0000</pubDate><guid>https://electronicmoon.space/posts/underscore-collection/</guid><description>_.each
_.each = _.forEach = function(obj,iteratee, context){ // 首先要优化回调过程 iteratee = optimizeCb(iteratee, context) var i, length if(isArrayLike(obj)){ for(i = 0, length = obj.length; i &amp;lt; length; i++){ // 数组迭代回调传入三参数：迭代值，迭代索引，迭代对象 iteratee(obj[i], i, obj) } } else { var keys = _.keys(obj) for (i = 0, length = keys.length; i &amp;lt; length; i++){ // 对象迭代回调传入三参数：迭代值，迭代 key，迭代对象 iteratee(obj[keys[i],keys[i],obj) } } // 返回对象自身，以便进行链式构造 } map-reduce map reduce 是函数式编程的重要组成，是一种对列表的操作思路。
map（映射）：一个映射过程就是将各个元素按照规则逐个映射为新的元素 reduce（规约）：一个规约过程迭代每个元素按照规则合并到一个目标对象上 map 在 underscore 中的实现 创建一个新列表或元素 遍历原列表或原对象的值，用指定的函数 func 作用于每个遍历到的元素，输出一个新的元素放入新列表或对象中 _.</description></item><item><title>About me</title><link>https://electronicmoon.space/about/</link><pubDate>Mon, 01 Jan 1900 00:00:00 +0000</pubDate><guid>https://electronicmoon.space/about/</guid><description>My name is Noah. I was an Electronic Engineering Student at 湖南大学. During School I studied C language with basic data structures and algorithms, in addition to participating in some computer hardware related courses. As for extra-curricular activities, I joined the designed and photography clubs, and I was an editor of 湖大青年. After graduation, I became a programmer after graduation.
My interests span programming languages, web development and classic algorithms. I have no formal training in computer science, but I have continued to keep learning on my own.</description></item></channel></rss>